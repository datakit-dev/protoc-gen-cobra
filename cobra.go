package main

import (
	"fmt"
	"sort"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func genFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+".cobra.pb.go", file.GoImportPath)
	g.P("// Code generated by protoc-gen-cobra. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, srv := range file.Services {
		if err := genService(g, srv); err != nil {
			return err
		}
	}

	return nil
}

var (
	serviceTemplateCode = `
func {{.GoName}}ClientCommand(options ...client.Option) *cobra.Command {
	cfg := client.NewConfig(options...)
	cmd := &cobra.Command{
		Use: cfg.CommandNamer("{{.GoName}}"),
		Short: "{{.GoName}} service client",
		Long: {{.Comments.Leading | cleanComments | printf "%q"}},{{if .Desc.Options.GetDeprecated}}
		Deprecated: "deprecated",{{end}}
	}
	cfg.BindFlags(cmd.PersistentFlags())
	cmd.AddCommand({{range .Methods}}
		_{{$.GoName}}{{.GoName}}Command(cfg),{{end}}
	)
	return cmd
}
`
	serviceTemplate = template.Must(template.New("service").
			Funcs(template.FuncMap{"cleanComments": cleanComments}).
			Parse(serviceTemplateCode))
	serviceImports = []protogen.GoImportPath{
		"github.com/NathanBaulch/protoc-gen-cobra/client",
		"github.com/spf13/cobra",
	}
)

func genService(g *protogen.GeneratedFile, service *protogen.Service) error {
	for _, imp := range serviceImports {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: imp})
	}
	if err := serviceTemplate.Execute(g, service); err != nil {
		return err
	}

	for _, mth := range service.Methods {
		if err := genMethod(g, mth); err != nil {
			return err
		}
	}

	return nil
}

var (
	methodTemplateCode = `
func _{{.Parent.GoName}}{{.GoName}}Command(cfg *client.Config) *cobra.Command {
	req := {{.InputInitializerCode}}

	cmd := &cobra.Command{
		Use: cfg.CommandNamer("{{.GoName}}"),
		Short: "{{.GoName}} RPC client",
		Long: {{.Comments.Leading | cleanComments | printf "%q"}},{{if .Desc.Options.GetDeprecated}}
		Deprecated: "deprecated",{{end}}
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "{{.Parent.GoName}}"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "{{.Parent.GoName}}", "{{.GoName}}"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := New{{.Parent.GoName}}Client(cc)
				v := &{{.Input.GoIdent.GoName}}{}
	{{if .Desc.IsStreamingClient}}
				stm, err := cli.{{.GoName}}(cmd.Context())
				if err != nil {
					return err
				}
				for {
					if err := in(v); err != nil {
						if err == io.EOF {
							_ = stm.CloseSend()
							break
						}
						return err
					}
					proto.Merge(v, req)
					if err = stm.Send(v); err != nil {
						return err
					}
				}
	{{else}}
				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)
		{{if .Desc.IsStreamingServer}}
				stm, err := cli.{{.GoName}}(cmd.Context(), v)
		{{else}}
				res, err := cli.{{.GoName}}(cmd.Context(), v)
		{{end}}
				if err != nil {
					return err
				}
	{{end}}
	{{if .Desc.IsStreamingServer}}
				for {
					res, err := stm.Recv()
					if err != nil {
						if err == io.EOF {
							break
						}
						return err
					}
					if err = out(res); err != nil {
						return err
					}
				}
				return nil
	{{else}}
		{{if .Desc.IsStreamingClient}}
				res, err := stm.CloseAndRecv()
				if err != nil {
					return err
				}
		{{end}}
				return out(res)
	{{end}}
			})
		},
	}

	{{.InputFieldFlagCode}}

	return cmd
}
`
	methodTemplate = template.Must(template.New("method").
			Funcs(template.FuncMap{"cleanComments": cleanComments}).
			Parse(methodTemplateCode))
	methodImports = []protogen.GoImportPath{
		"github.com/NathanBaulch/protoc-gen-cobra/client",
		"github.com/NathanBaulch/protoc-gen-cobra/flag",
		"github.com/NathanBaulch/protoc-gen-cobra/iocodec",
		"github.com/spf13/cobra",
		"google.golang.org/grpc",
		"google.golang.org/protobuf/proto",
	}
)

func genMethod(g *protogen.GeneratedFile, method *protogen.Method) error {
	for _, imp := range methodImports {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: imp})
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "io"})
	}

	initCode, flagCode := walkFields(g, method.Input, nil, false, make(map[protogen.GoIdent]bool), 0, "")
	data := struct {
		*protogen.Method
		InputInitializerCode string
		InputFieldFlagCode   string
	}{method, initCode, flagCode}
	return methodTemplate.Execute(g, data)
}

var (
	basicTypes = map[protoreflect.Kind]struct{ Type, Parse, Value, Slice, Pointer, Default string }{
		protoreflect.BoolKind:   {"bool", "ParseBoolE", "BoolVar", "BoolSliceVar", "BoolPointerVar", "false"},
		protoreflect.Int32Kind:  {"int32", "ParseInt32E", "Int32Var", "Int32SliceVar", "Int32PointerVar", "0"},
		protoreflect.Uint32Kind: {"uint32", "ParseUint32E", "Uint32Var", "Uint32SliceVar", "Uint32PointerVar", "0"},
		protoreflect.Int64Kind:  {"int64", "ParseInt64E", "Int64Var", "Int64SliceVar", "Int64PointerVar", "0"},
		protoreflect.Uint64Kind: {"uint64", "ParseUint64E", "Uint64Var", "Uint64SliceVar", "Uint64PointerVar", "0"},
		protoreflect.FloatKind:  {"float32", "ParseFloat32E", "Float32Var", "Float32SliceVar", "Float32PointerVar", "0"},
		protoreflect.DoubleKind: {"float64", "ParseFloat64E", "Float64Var", "Float64SliceVar", "Float64PointerVar", "0"},
		protoreflect.StringKind: {"string", "ParseStringE", "StringVar", "StringSliceVar", "StringPointerVar", `""`},
		protoreflect.BytesKind:  {"bytesBase64", "ParseBytesBase64E", "BytesBase64Var", "BytesBase64SliceVar", "", "nil"},
	}
	wrappersPkg  = protogen.GoImportPath("google.golang.org/protobuf/types/known/wrapperspb")
	timestampPkg = protogen.GoImportPath("google.golang.org/protobuf/types/known/timestamppb")
	durationPkg  = protogen.GoImportPath("google.golang.org/protobuf/types/known/durationpb")
	knownTypes   = map[protogen.GoIdent]struct{ Type, Parse, Value, Slice string }{
		timestampPkg.Ident("Timestamp"):  {"timestamp", "ParseTimestampE", "TimestampVar", "TimestampSliceVar"},
		durationPkg.Ident("Duration"):    {"duration", "ParseDurationE", "DurationVar", "DurationSliceVar"},
		wrappersPkg.Ident("DoubleValue"): {"float64", "ParseDoubleWrapperE", "DoubleWrapperVar", "DoubleWrapperSliceVar"},
		wrappersPkg.Ident("FloatValue"):  {"float32", "ParseFloatWrapperE", "FloatWrapperVar", "FloatWrapperSliceVar"},
		wrappersPkg.Ident("Int64Value"):  {"int64", "ParseInt64WrapperE", "Int64WrapperVar", "Int64WrapperSliceVar"},
		wrappersPkg.Ident("UInt64Value"): {"uint64", "ParseUInt64WrapperE", "UInt64WrapperVar", "UInt64WrapperSliceVar"},
		wrappersPkg.Ident("Int32Value"):  {"int32", "ParseInt32WrapperE", "Int32WrapperVar", "Int32WrapperSliceVar"},
		wrappersPkg.Ident("UInt32Value"): {"uint32", "ParseUInt32WrapperE", "UInt32WrapperVar", "UInt32WrapperSliceVar"},
		wrappersPkg.Ident("BoolValue"):   {"bool", "ParseBoolWrapperE", "BoolWrapperVar", "BoolWrapperSliceVar"},
		wrappersPkg.Ident("StringValue"): {"string", "ParseStringWrapperE", "StringWrapperVar", "StringWrapperSliceVar"},
		wrappersPkg.Ident("BytesValue"):  {"bytesBase64", "ParseBytesBase64WrapperE", "BytesBase64WrapperVar", "BytesBase64WrapperSliceVar"},
	}
)

func walkFields(g *protogen.GeneratedFile, message *protogen.Message, path []string, deprecated bool, visited map[protogen.GoIdent]bool, level int, postSetCode string) (string, string) {
	initLines := make(map[int]string)
	flagLines := make(map[int]string, len(message.Fields))

	target := "req"
	if level > 0 {
		target = strings.Join(path[:level], "")
	}

	for _, fld := range message.Fields {
		path := append(path, fld.GoName)

		if f := flagFormat(g, fld); f != "" {
			flagName := fmt.Sprintf("cfg.FlagNamer(%q)", strings.Join(path, " "))
			comment := cleanComments(fld.Comments.Leading)
			var flagLine string
			if fld.Oneof != nil && !fld.Oneof.Desc.IsSynthetic() {
				varName := strings.Join(path, "")
				goPath := fmt.Sprintf("&%s.%s", varName, fld.GoName)
				flagLine = fmt.Sprintf("%s := &%s{}\n", varName, g.QualifiedGoIdent(fld.GoIdent))
				flagLine += fmt.Sprintf(f, goPath, flagName, comment)
				target := strings.Join(append([]string{target}, path[level:len(path)-1]...), ".")
				postSetCode := fmt.Sprintf("%s.%s = %s", target, fld.Oneof.GoName, varName)
				flagLine += fmt.Sprintf("\nflag.WithPostSetHook(cmd.PersistentFlags(), %s, func() { %s })", flagName, postSetCode)
			} else {
				goPath := fmt.Sprintf("&%s.%s", target, strings.Join(path[level:], "."))
				flagLine = fmt.Sprintf(f, goPath, flagName, comment)
			}
			if postSetCode != "" {
				flagLine += fmt.Sprintf("\nflag.WithPostSetHook(cmd.PersistentFlags(), %s, func() { %s })", flagName, postSetCode)
			}
			if deprecated || fld.Desc.Options().(*descriptorpb.FieldOptions).GetDeprecated() {
				flagLine += fmt.Sprintf("\n_ = cmd.PersistentFlags().MarkDeprecated(%s, \"deprecated\")", flagName)
			}
			flagLines[fld.Desc.Index()] = flagLine
		} else if normalizeKind(fld.Desc.Kind()) == protoreflect.MessageKind {
			if fld.Desc.IsList() {
				// message list not supported
			} else if fld.Desc.IsMap() {
				// limited map support
			} else if visited[message.GoIdent] = true; visited[fld.Message.GoIdent] {
				// cycle detected
			} else {
				m := make(map[protogen.GoIdent]bool, len(visited))
				for k, v := range visited {
					m[k] = v
				}

				level := level
				postSetCode := postSetCode
				if fld.Oneof != nil && !fld.Oneof.Desc.IsSynthetic() {
					if postSetCode != "" {
						postSetCode += ";"
					}
					target := strings.Join(append([]string{target}, path[level:len(path)-1]...), ".")
					postSetCode += fmt.Sprintf("%s.%s = &%s{%s: %s}", target, fld.Oneof.GoName, g.QualifiedGoIdent(fld.GoIdent), fld.GoName, strings.Join(path, ""))
					level = len(path)
				}
				initCode, flagCode := walkFields(g, fld.Message, path, deprecated, m, level, postSetCode)
				if initCode != "" && (fld.Oneof == nil || fld.Oneof.Desc.IsSynthetic()) {
					initLines[fld.Desc.Index()] = fmt.Sprintf("%s: %s,", fld.GoName, initCode)
				}
				if flagCode != "" {
					if fld.Oneof != nil && !fld.Oneof.Desc.IsSynthetic() {
						flagName := fmt.Sprintf("cfg.FlagNamer(%q)", strings.Join(path, " "))
						flagLine := fmt.Sprintf("%s := %s\n", strings.Join(path, ""), initCode)
						flagLine += fmt.Sprintf("cmd.PersistentFlags().Bool(%s, false, \"\")\n", flagName)
						flagLine += fmt.Sprintf("flag.WithPostSetHook(cmd.PersistentFlags(), %s, func() { %s })\n", flagName, postSetCode)
						flagCode = flagLine + flagCode
					}
					flagLines[fld.Desc.Index()] = flagCode
				}
			}
		}
	}

	initCode := ""
	if len(initLines) > 0 {
		initCode = fmt.Sprintf("\n%s\n", strings.Join(sortedLines(initLines), "\n"))
	}
	return fmt.Sprintf("&%s{%s}", g.QualifiedGoIdent(message.GoIdent), initCode), strings.Join(sortedLines(flagLines), "\n")
}

func flagFormat(g *protogen.GeneratedFile, fld *protogen.Field) string {
	k := normalizeKind(fld.Desc.Kind())

	if bt, ok := basicTypes[k]; ok {
		if fld.Desc.IsList() {
			switch k {
			case protoreflect.Uint32Kind, protoreflect.Uint64Kind, protoreflect.BytesKind:
				return fmt.Sprintf("flag.%s(cmd.PersistentFlags(), %%s, %%s, %%q)", bt.Slice)
			default:
				return fmt.Sprintf("cmd.PersistentFlags().%s(%%s, %%s, nil, %%q)", bt.Slice)
			}
		} else if k == protoreflect.BytesKind {
			return fmt.Sprintf("flag.%s(cmd.PersistentFlags(), %%s, %%s, %%q)", bt.Value)
		} else if (fld.Oneof == nil && fld.Desc.HasPresence()) || (fld.Oneof != nil && fld.Oneof.Desc.IsSynthetic()) {
			return fmt.Sprintf("flag.%s(cmd.PersistentFlags(), %%s, %%s, %%q)", bt.Pointer)
		} else {
			return fmt.Sprintf("cmd.PersistentFlags().%s(%%s, %%s, %s, %%q)", bt.Value, bt.Default)
		}
	}

	switch k {
	case protoreflect.EnumKind:
		if fld.Desc.IsList() {
			return "flag.EnumSliceVar(cmd.PersistentFlags(), %s, %s, %q)"
		} else if fld.Desc.HasPresence() {
			return "flag.EnumPointerVar(cmd.PersistentFlags(), %s, %s, %q)"
		} else {
			return "flag.EnumVar(cmd.PersistentFlags(), %s, %s, %q)"
		}
	case protoreflect.MessageKind:
		if kt, ok := knownTypes[fld.Message.GoIdent]; ok {
			if fld.Desc.IsList() {
				return fmt.Sprintf("flag.%s(cmd.PersistentFlags(), %%s, %%s, %%q)", kt.Slice)
			} else {
				return fmt.Sprintf("flag.%s(cmd.PersistentFlags(), %%s, %%s, %%q)", kt.Value)
			}
		}
		if fld.Desc.IsMap() {
			kk := normalizeKind(fld.Desc.MapKey().Kind())
			vk := normalizeKind(fld.Desc.MapValue().Kind())
			if kk == protoreflect.StringKind {
				switch vk {
				case protoreflect.StringKind:
					return "cmd.PersistentFlags().StringToStringVar(%s, %s, nil, %q)"
				case protoreflect.Int64Kind:
					return "cmd.PersistentFlags().StringToInt64Var(%s, %s, nil, %q)"
				}
			}

			if bt, ok := basicTypes[kk]; ok {
				keyParser := "flag." + bt.Parse
				valParser := ""
				switch vk {
				case protoreflect.EnumKind:
					id := g.QualifiedGoIdent(fld.Message.Fields[1].Enum.GoIdent)
					valParser = fmt.Sprintf("flag.ParseEnumE[%s]", id)
				case protoreflect.MessageKind:
					id := fld.Message.Fields[1].Message.GoIdent
					if kt, ok := knownTypes[id]; ok {
						valParser = "flag." + kt.Parse
					}
				default:
					if bt, ok := basicTypes[vk]; ok {
						valParser = "flag." + bt.Parse
					}
				}
				if valParser != "" {
					return fmt.Sprintf("flag.MapVar(cmd.PersistentFlags(), %s, %s, %%s, %%s, %%q)", keyParser, valParser)
				}
			}
		}
	}

	return ""
}

func normalizeKind(kind protoreflect.Kind) protoreflect.Kind {
	switch kind {
	case protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return protoreflect.Int32Kind
	case protoreflect.Fixed32Kind:
		return protoreflect.Uint32Kind
	case protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return protoreflect.Int64Kind
	case protoreflect.Fixed64Kind:
		return protoreflect.Uint64Kind
	case protoreflect.GroupKind:
		return protoreflect.MessageKind
	default:
		return kind
	}
}

func sortedLines(m map[int]string) []string {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	sort.Ints(keys)
	vals := make([]string, len(m))
	for i, k := range keys {
		vals[i] = m[k]
	}
	return vals
}

func cleanComments(comments protogen.Comments) string {
	return strings.TrimSpace(string(comments))
}
